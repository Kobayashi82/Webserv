Fix leaks and data race

			-----------------------------------------------------

siege -b -c 255 -t 60S 127.0.0.1:8090								-	Stress test

ps --ppid $(pgrep webserv) -o pid,stat,cmd							-	Zombie processes

curl --resolve default:8081:127.0.0.1 http://default:8081/support.html				-	Default server
curl --resolve secundary:8090:127.0.0.1 http://secundary:8090					-	Secundary server
curl --resolve non_valid:8081:127.0.0.1 http://non_valid:8081/support.html			-	No server with this name, using Default

curl -X POST -H "Content-Type: plain/text" --data "123456789" 127.0.0.1:8090/index.py		-	Load html
curl -X POST -H "Content-Type: plain/text" --data "1234567890" 127.0.0.1:8090/index.py		-	Payload too large

curl -X POST -H "Content-Type: application/x-www-form-urlencoded" \
--data "u=[email]&p=[password]&remember_me=off" 127.0.0.1:8081/login.php			-	Test POST method

curl -s http://127.0.0.1:8083/cgi/sample.cgi?algunos_datos | grep algunos_datos			-	Test GET method

curl -i -X "DELETE" http://127.0.0.1:8081/delete.php?file=some_file				-	Test DELETE method

curl -X "UNKNOWN" http://127.0.0.1:8083								-	Test UNKNOWN method

			-----------------------------------------------------

Pregunta: ¿Podrían explicar los conceptos básicos de un servidor HTTP? ¿Cómo maneja las solicitudes y respuestas?

Un servidor HTTP es responsable de recibir solicitudes de los clientes (navegadores web u otros clientes HTTP),
procesarlas, y devolver una respuesta adecuada. Utiliza el protocolo HTTP para la comunicación. El flujo básico es:

El cliente envía una solicitud HTTP, como una solicitud GET para obtener una página web.

El servidor recibe la solicitud, procesa la información solicitada (buscar archivos, ejecutar scripts, etc.), y devuelve una respuesta HTTP.

La respuesta incluye un código de estado (como 200 para éxito o 404 para no encontrado) y el contenido solicitado (como una página HTML o un archivo).

Pregunta: ¿Qué función usaron para la multiplexación de I/O?

La multiplexación de I/O permite a un servidor manejar múltiples conexiones (o archivos) simultáneamente sin necesidad de crear un hilo o proceso para cada conexión. Esto mejora la eficiencia.
En Linux, hay varias formas de lograr esto, como select(), poll(), o el más avanzado epoll().

Cada una tiene sus ventajas y limitaciones en cuanto a escalabilidad y rendimiento.

Pregunta: ¿Podrían explicar cómo funciona select() (o su equivalente)?

select() es una función usada para monitorear múltiples descriptores de archivos (como sockets) y ver si están listos para alguna operación (lectura, escritura, o si han ocurrido excepciones).
Básicamente, se pasa una lista de descriptores de archivo y se le dice a select() que espere hasta que alguno de esos descriptores esté listo para ser leído o escrito sin bloquear.

Epoll (más moderno) funciona de manera similar, pero es más eficiente para manejar un gran número de conexiones simultáneas, ya que no necesita escanear constantemente todos los descriptores de archivos, sino que se basa en eventos que le notifican cuándo un archivo o socket está listo para ser procesado.